package de.scribble.lp.fishrigging;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import javax.annotation.Nullable;

import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.tuple.Pair;

import net.minecraft.enchantment.Enchantment;
import net.minecraft.enchantment.EnchantmentHelper;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.init.PotionTypes;
import net.minecraft.item.ItemStack;
import net.minecraft.potion.PotionUtils;

public class FishManip2 {
	
	private File fileLocation;

	public FishManip2(File saveFile) {
		fileLocation=saveFile;
		createFile(saveFile);
	}

	private List<String> createFile(File saveFile) {
		if (saveFile.exists())
			return null;
		
		List<String> toWrite= new ArrayList<>();
		toWrite.add("#This file was generated by FishManip, the author is Scribble. Leave blank to disable this feature. Everything starting with a hashtag is a comment\n"
				+ "#\n"
				+ "#Once an item has been caught, this file will update and remove the topmost item from your list\n"
				+ "#If there is an error, the file will show you which line it is\n"
				+ "#-----------------------------Possible items-----------------------------\n"
				+ "#(you can just delete the # at the start of the line if you want that item)\n"
				+ "#\n");
		
		for(String item : PossibleItems.getNames()) {
			toWrite.add("#"+item+"\n");
		}
		try {
			FileUtils.writeLines(fileLocation, toWrite);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return toWrite;
	}
	
	private boolean isActive() {
		List<String> completeFile;
		try {
			completeFile = readFile();
		} catch (IOException e) {
			System.out.println("Failed to read file for FishManip for some reason");
			e.printStackTrace();
			return false;
		}
		return false;
	}
	
	private List<QueuedItem> parseItems(List<String> lines){
		for(String line : lines) {
			
			if(line.startsWith("#")) //Comments!
				continue;
			
			String[] blocks = line.split(";");
			
		}
		return null;
	}
	
	private List<String> readFile() throws IOException{
		if(fileLocation.exists())
			return FileUtils.readLines(fileLocation, StandardCharsets.UTF_8);
		else
			return createFile(fileLocation);
	}
	
	enum PossibleItems {
		COD("cod", new ItemStack(Items.FISH, 1, 0)),
		SALMON("salmon", new ItemStack(Items.FISH, 1, 1)),
		CLOWNFISH("clownfish", new ItemStack(Items.FISH, 1, 2)),
		PUFFERFISH("pufferfish", new ItemStack(Items.FISH, 1, 3)),
		LEATHER_BOOTS("leather_boots", new ItemStack(Items.LEATHER_BOOTS), Pair.of(0, 58)),
		WATER_POTION("water_potion", waterPotion()),
		FISHING_ROD_JUNK("fishing_rod_junk", new ItemStack(Items.FISHING_ROD), Pair.of(0, 57)),
		INC_SAC("ink_sac", new ItemStack(Items.DYE, 10, 0)),
		TRIPWIRE_HOOK("tripwire_hook", new ItemStack(Blocks.TRIPWIRE_HOOK)),
		ROTTEN_FLESH("rotten_flesh", new ItemStack(Items.ROTTEN_FLESH)),
		WATERLILY("waterlily", new ItemStack(Blocks.WATERLILY)),
		NAME_TAG("name_tag", new ItemStack(Items.NAME_TAG)),
		SADDLE("saddle", new ItemStack(Items.SADDLE)),
		BOW("bow", new ItemStack(Items.BOW), Pair.of(0, 96)),
		FISHING_ROD_TREASURE("fishing_rod_treasure", new ItemStack(Items.FISHING_ROD), Pair.of(0, 57)),
		BOOK("book", new ItemStack(Items.ENCHANTED_BOOK));
		
		
		private final String name;
		private final ItemStack stack;
		private final Pair<Integer, Integer> damageRange;
		
		PossibleItems(String name, ItemStack stack) {
			this(name, stack, null);
		}
		
		PossibleItems(String name, ItemStack stack, Pair<Integer, Integer> damageRange) {
			this.name = name;
			this.stack = stack;
			this.damageRange = damageRange;
		}
		
		private static ItemStack waterPotion() {
			ItemStack stack = new ItemStack(Items.POTIONITEM);
			return PotionUtils.addPotionToItemStack(stack, PotionTypes.WATER);
		}
		
		public static List<String> getNames(){
			List<String> out = new ArrayList<>();
			PossibleItems[] values = values();
			for(PossibleItems items : values) {
				out.add(items.name);
			}
			return out;
		}
		
		public static ItemStack getStack(String name) {
			PossibleItems[] values = values();
			for(PossibleItems items : values) {
				if(items.name.equals(name)) {
					return items.stack.copy();
				}
			}
			return null;
		}
		
		public static Pair<Integer, Integer> getDamageRange(String name){
			PossibleItems[] values = values();
			for(PossibleItems items : values) {
				if(items.name.equals(name)) {
					return items.damageRange;
				}
			}
			return null;
		}
		
		public static boolean isValid(QueuedItem item) {
			return isValid(item.name, item.damage, item.enchantments);
		}
		
		public static boolean isValid(String name, @Nullable Integer damage, @Nullable Map<Enchantment, Integer> enchlist) {
			if(!getNames().contains(name))
				return false;
			
			if(damage != null) {
				if(!isValidDamage(name, damage))
					return false;
			}
			
			if(enchlist!=null) {
				if(!isValidEnchantments(name, enchlist))
					return false;
			}
			return true;
		}
		
		private static boolean isValidDamage(String name, Integer damage) {
			Pair<Integer, Integer> range = getDamageRange(name);
			if(damage!=null) {
				return damage>=range.getLeft() && damage<=range.getRight();
			}
			return false;
		}
		
		private static boolean isValidEnchantments(String name, Map<Enchantment, Integer> enchlistMap) {
			
			Set<Enchantment> enchlist = enchlistMap.keySet();
			
			for(Enchantment firstEnch : enchlist) {
				
				ItemStack stack = getStack(name);
				
				// Test if enchantments can apply
				if(!firstEnch.canApply(stack)) {
					return false;
				}
				
				//Test for compatibility
				for(Enchantment secondEnch : enchlist) {
					if(firstEnch.equals(secondEnch))
						continue;
					if(!firstEnch.isCompatibleWith(secondEnch)) 
						return false;
				}
				EnchantmentHelper.setEnchantments(null, stack);
			}
			
			// Testing for max min enchantment
			Set<Entry<Enchantment, Integer>> enchSet = enchlistMap.entrySet();
			for(Entry<Enchantment, Integer> enchEntry : enchSet) {
				Enchantment ench = enchEntry.getKey();
				int lvl = enchEntry.getValue();
				if(ench.getMaxLevel() > lvl) {
					return false;
				}
				if(ench.getMinLevel() < lvl) {
					return false;
				}
			}
			return true;
		}
	}
	
	class QueuedItem{
		
		String name;
		Integer damage;
		Map<Enchantment, Integer> enchantments;
		
		public QueuedItem(String name) {
			this(name, null, null);
		}
		
		public QueuedItem(String name, Integer damage, Map<Enchantment, Integer> enchantments) {
			this.name = name;
			this.damage = damage;
			this.enchantments = enchantments;
		}
		
	}
}
