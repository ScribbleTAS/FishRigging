package de.scribble.lp.fishrigging;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nullable;

import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.tuple.Pair;

import net.minecraft.enchantment.Enchantment;
import net.minecraft.enchantment.EnchantmentHelper;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.init.PotionTypes;
import net.minecraft.item.ItemStack;
import net.minecraft.potion.PotionUtils;

public class FishManip {
	
	private File fileLocation;

	public FishManip(File saveFile) {
		fileLocation=saveFile;
		createFile(saveFile);
	}
	
	public File getFileLocation() {
		return fileLocation;
	}

	private List<String> createFile(File saveFile) {
		if (saveFile.exists())
			return null;
		
		List<String> toWrite= new ArrayList<>();
		toWrite.add("#This file was generated by FishManip, the author is Scribble. Leave blank to disable this feature. Everything starting with a hashtag is a comment\n"
				+ "#\n"
				+ "#If fishmanip is active, fishing rng will be the best possible rng"
				+ "#Once an item has been caught, this file will update and remove the topmost item from your list\n"
				+ "#If there is an error, the file will show you which line and what the error is\n"
				+ "#\n"
				+ "#Some items require damage values and or enchantments. The syntax for that is as follows:\n"
				+ "#\n"
				+ "#<item_name>;damage:<damage_value>;enchant:<first_enchantment_name>[<ench_level>],<second_enchantment_name>[<ench_level>]\n"
				+ "#\n"
				+ "#Example: fishing_rod_treasure;damage:0;enchant:unbreaking[1],lure[3]\n"
				+ "#\n"
				+ "#\n"
				+ "#-----------------------------Possible items-----------------------------\n"
				+ "#\n"
				+ "#\n");
		
		for(String item : PossibleItems.getNames()) {
			toWrite.add("#"+item);
		}
		try {
			FileUtils.writeLines(fileLocation, toWrite);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return toWrite;
	}
	
	public boolean isActive() {
		List<String> completeFile;
		try {
			completeFile = readFile();
		} catch (IOException e) {
			System.out.println("Failed to read file for FishManip for some reason");
			e.printStackTrace();
			return false;
		}
		for (String line : completeFile) {
			if (line.startsWith("#")) {
				continue;
			} else if(line!=null&&!line.isEmpty()) {
				return true;
			}
		}
		return false;
	}
	
	public ItemStack getItemFromTop() {
		List<String> completeFile;
		List<String> output = new ArrayList<>();
		
		ItemStack barrier = new ItemStack(Blocks.BARRIER);
		barrier.setStackDisplayName("Something went wrong in FishRigging. Check your file");
		
		ItemStack topmostItem = barrier.copy();
		
		try {
			completeFile = readFile();
		} catch (IOException e) {
			System.out.println("Failed to read file for FishManip for some reason");
			e.printStackTrace();
			return topmostItem;
		}
		
		int linenumber = 0;
		for(String line : completeFile) {
			
			if(line.startsWith("#") || line.isEmpty()) {  //Comments!
				output.add(line);
				continue;
			}
			
			if(line.contains("Mistake in this line:")) { //If there is already an error in this line, remove the old error message
				line=line.replaceFirst("Mistake in this line:.*->\\s*", "");
			}
			
			linenumber++;
			
			QueuedItem item = null;
			try {
				item = parseLine(line);
			} catch (Exception e) {
				output.add(errorLine(line, e.getMessage()));
				continue;
			}
			
			try {
				if(linenumber == 1) {
					topmostItem = PossibleItems.constructItem(item);
					continue;
				}
				PossibleItems.constructItem(item);
				output.add(line);
			} catch (Exception e) {
				output.add(errorLine(line, e.getMessage()));
			}
		}
		if(fileLocation.exists()) {
			fileLocation.delete();
		}
		try {
			FileUtils.writeLines(fileLocation, output);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return topmostItem;
	}
	
	private String errorLine(String line, String message) {
		
		return String.format("Mistake in this line: %s -> %s", message, line);
	}
	
	private QueuedItem parseLine(String line) throws Exception{
		line = line.replaceFirst("\\s*#.*", ""); //Get rid of comments
		String[] blocks = line.split(";");
		String name;
		Integer damage = null;
		Map<Enchantment, Integer> enchs = null;
		
		name = blocks[0];
		
		for(int i = 1; i<blocks.length; i++) {
			
			Pattern damagepattern = Pattern.compile("damage:(\\d+)");
			Matcher damagematcher = damagepattern.matcher(blocks[i]);
			
			if (damagematcher.find()) {
				damage = Integer.parseInt(damagematcher.group(1));
			} else {
				if (blocks[i].startsWith("enchant:")) {
					enchs = new HashMap<>();
					Pattern enchpattern = Pattern.compile("(\\w+)\\[(\\d)\\]");

					String enchString = blocks[i].replace("enchant:", "");
					String[] enchSplit = enchString.split(",");

					for (String ench : enchSplit) {
						Matcher enchmatcher = enchpattern.matcher(ench);
						if (enchmatcher.find()) {
							Enchantment key = Enchantment.getEnchantmentByLocation(enchmatcher.group(1));
							if(key==null) {
								throw new Exception(String.format("Can't read enchantment: %s", enchmatcher.group(1)));
							}
							int lvl = Integer.parseInt(enchmatcher.group(2));
							enchs.put(key, lvl);
						}
					}
				}
			}
		}
		
		return new QueuedItem(name, damage, enchs);
	}

	private List<String> readFile() throws IOException{
		if(fileLocation.exists())
			return FileUtils.readLines(fileLocation, StandardCharsets.UTF_8);
		else
			return createFile(fileLocation);
	}
	
	enum PossibleItems {
		COD("cod", new ItemStack(Items.FISH, 1, 0), null),
		SALMON("salmon", new ItemStack(Items.FISH, 1, 1), null),
		CLOWNFISH("clownfish", new ItemStack(Items.FISH, 1, 2), null),
		PUFFERFISH("pufferfish", new ItemStack(Items.FISH, 1, 3), null),
		LEATHER_BOOTS("leather_boots", new ItemStack(Items.LEATHER_BOOTS), Pair.of(0, 58), false, "Possible damage: 0-58, This item can't be enchanted, Example: leather_boots;damage:0"),
		WATER_POTION("water_potion", waterPotion(), null),
		FISHING_ROD_JUNK("fishing_rod_junk", new ItemStack(Items.FISHING_ROD), Pair.of(0, 57), false, "Possible damage: 0-57, This item can't be enchanted, Example: fishing_rod_junk;damage:0"),
		INC_SAC("ink_sac", new ItemStack(Items.DYE, 10, 0), null),
		TRIPWIRE_HOOK("tripwire_hook", new ItemStack(Blocks.TRIPWIRE_HOOK), null),
		ROTTEN_FLESH("rotten_flesh", new ItemStack(Items.ROTTEN_FLESH), null),
		WATERLILY("waterlily", new ItemStack(Blocks.WATERLILY), null),
		NAME_TAG("name_tag", new ItemStack(Items.NAME_TAG), null),
		SADDLE("saddle", new ItemStack(Items.SADDLE), null),
		BOW("bow", new ItemStack(Items.BOW), Pair.of(0, 96), true, "Possible damage: 0-96, This item has to be enchanted, Example: bow;damage:0;enchant:infinity[1],unbreaking[3]"),
		FISHING_ROD_TREASURE("fishing_rod_treasure", new ItemStack(Items.FISHING_ROD), Pair.of(0, 57), true, "Possible damage: 0-57, This item has to be enchanted, Example: fishing_rod_treasure;damage:0;enchant:lure[1],unbreaking[3]"),
		BOOK("book", new ItemStack(Items.ENCHANTED_BOOK), null, true, "This item has to be enchanted, Example: book;enchant:frost_walker[1]");
		
		
		private final String name;
		private final ItemStack stack;
		private final Pair<Integer, Integer> damageRange;
		private final boolean enchantmentMandatory;
		private final String comment;
		
		PossibleItems(String name, ItemStack stack, String comment) {
			this(name, stack, null, false, comment);
		}
		
		PossibleItems(String name, ItemStack stack, Pair<Integer, Integer> damageRange, boolean enchMandatory, String comment) {
			this.name = name;
			this.stack = stack;
			this.damageRange = damageRange;
			this.enchantmentMandatory = enchMandatory;
			this.comment = comment;
		}
		
		private static ItemStack waterPotion() {
			ItemStack stack = new ItemStack(Items.POTIONITEM);
			return PotionUtils.addPotionToItemStack(stack, PotionTypes.WATER);
		}
		
		public static List<String> getNames(){
			List<String> out = new ArrayList<>();
			PossibleItems[] values = values();
			for(PossibleItems items : values) {
				out.add(items.toString());
			}
			return out;
		}
		
		public static PossibleItems getFromName(String name) {
			PossibleItems[] values = values();
			for(PossibleItems items : values) {
				if(items.name.equals(name)) {
					return items;
				}
			}
			return null;
		}
		
		public static ItemStack getStack(String name) {
			return getFromName(name).stack.copy();
		}
		
		private static Exception isValid(QueuedItem item) {
			if(item == null) {
				return new Exception("Syntax error, can't read this line");
			}
			return isValid(item.name, item.damage, item.enchantments);
		}
		
		private static Exception isValid(String name, @Nullable Integer damage, @Nullable Map<Enchantment, Integer> enchlist) {
			
			PossibleItems item = getFromName(name);
			
			if(item == null)
				return new Exception("Couldn't find this in the list of possible fished items");
			
			Exception e = isValidDamage(item, damage);
			if(e != null)
				return e;
			
			e = isValidEnchantments(item, enchlist);
			if (e != null)
				return e;
			
			return null;
		}
		
		private static Exception isValidDamage(PossibleItems item, Integer damage) {
			Pair<Integer, Integer> range = item.damageRange;
			if(damage!=null) {
				if(range == null) {
					return new Exception("This item doesn't accept a damage property");
				}
				if(damage>=range.getLeft() && damage<=range.getRight()) {
					return null;
				} else {
					return new Exception(String.format("The damage is not within %s-%s", range.getLeft(), range.getRight()));
				}
			} else {
				if(range != null) {
					return new Exception(String.format("The damage property is mandatory for this item. It has to be within %s-%s", range.getLeft(), range.getRight()));
				}
				return null;
			}
		}
		
		private static Exception isValidEnchantments(PossibleItems item, Map<Enchantment, Integer> enchlistMap) {
			
			if(enchlistMap == null) {
				if(item.enchantmentMandatory) {
					return new Exception("The enchantment property is mandatory for this item");
				}else {
					return null;
				}
			}
			//Test if enchantment is mandatory
			if(!item.enchantmentMandatory)
				return new Exception("This item doesn't accept an enchantment property");
			
			Set<Enchantment> enchlist = enchlistMap.keySet();
			
			for(Enchantment firstEnch : enchlist) {
				
				ItemStack stack = item.stack.copy();
				
				// Test if enchantments can apply
				if(!firstEnch.canApply(stack) && !stack.getItem().equals(Items.ENCHANTED_BOOK)) {
					return new Exception(String.format("This item can't be enchanted with %s", firstEnch.getName()));
				}
				
				//Test for compatibility
				for(Enchantment secondEnch : enchlist) {
					if(firstEnch.equals(secondEnch))
						continue;
					if(!firstEnch.isCompatibleWith(secondEnch)) 
						return new Exception(String.format("Enchantment %s is incompatible with %s", firstEnch.getName(), secondEnch.getName()));
				}
			}
			
			// Testing for max min enchantment
			Set<Entry<Enchantment, Integer>> enchSet = enchlistMap.entrySet();
			for(Entry<Enchantment, Integer> enchEntry : enchSet) {
				Enchantment ench = enchEntry.getKey();
				int lvl = enchEntry.getValue();
				if(ench.getMaxLevel() < lvl) {
					return new Exception(String.format("The level of %s is too high. Max: %s", ench.getName(), ench.getMaxLevel()));
				}
				if(ench.getMinLevel() > lvl) {
					return new Exception(String.format("The level of %s is too low. Min: %s", ench.getName(), ench.getMinLevel()));
				}
			}
			return null;
		}
		
		static ItemStack constructItem(QueuedItem item) throws Exception{
			
			Exception e = isValid(item);
			if(e!=null)
				throw e;
			
			ItemStack itemStack = getStack(item.name);
			if(item.damage!=null) {
				itemStack.setItemDamage(item.damage);
			}
			if(item.enchantments!=null) {
				EnchantmentHelper.setEnchantments(item.enchantments, itemStack);
			}
			return itemStack;
		}
		
		@Override
		public String toString() {
			String out = name;
			if(comment!=null) {
				out = out.concat("\t\t\t\t\t\t\t\t#"+comment);
			}
			return out;
		}
	}
	
	class QueuedItem{
		
		String name;
		Integer damage;
		Map<Enchantment, Integer> enchantments;
		
		public QueuedItem(String name) {
			this(name, null, null);
		}
		
		public QueuedItem(String name, Integer damage, Map<Enchantment, Integer> enchantments) {
			this.name = name;
			this.damage = damage;
			this.enchantments = enchantments;
		}
		
	}
}
